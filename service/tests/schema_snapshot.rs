//! Schema snapshot testing.
//!
//! This test compares the current database schema against a committed snapshot
//! to detect unintentional schema drift. When migrations intentionally change
//! the schema, regenerate the snapshot.
//!
//! Run with: `cargo test schema_snapshot`
//! Regenerate snapshot: `cargo test -- generate_schema_snapshot --ignored`

mod common;

use common::test_db::isolated_db;
use tc_test_macros::shared_runtime_test;

const SCHEMA_SNAPSHOT_PATH: &str = concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/tests/snapshots/schema.sql"
);

/// Extracts the current schema from the database in a normalized format.
async fn extract_schema(pool: &sqlx::PgPool) -> String {
    // Get all table definitions
    let tables: Vec<(String, String, String, String, i32, String)> = sqlx::query_as(
        r#"
        SELECT
            t.table_name,
            c.column_name,
            c.data_type,
            COALESCE(c.column_default, ''),
            CASE WHEN c.is_nullable = 'NO' THEN 0 ELSE 1 END as nullable,
            COALESCE(c.udt_name, '')
        FROM information_schema.tables t
        JOIN information_schema.columns c ON t.table_name = c.table_name
        WHERE t.table_schema = 'public'
        AND t.table_type = 'BASE TABLE'
        AND t.table_name NOT LIKE '_sqlx%'
        ORDER BY t.table_name, c.ordinal_position
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract schema");

    // Get all indexes
    let indexes: Vec<(String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tablename,
            indexname,
            indexdef
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename NOT LIKE '_sqlx%'
        ORDER BY tablename, indexname
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract indexes");

    // Get all constraints
    let constraints: Vec<(String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tc.table_name,
            tc.constraint_name,
            tc.constraint_type
        FROM information_schema.table_constraints tc
        WHERE tc.table_schema = 'public'
        AND tc.table_name NOT LIKE '_sqlx%'
        ORDER BY tc.table_name, tc.constraint_name
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract constraints");

    // Build normalized schema representation
    let mut output = String::new();
    output.push_str("-- Schema Snapshot\n");
    output.push_str("-- Generated by schema_snapshot test\n");
    output.push_str("-- Regenerate: cargo test -- generate_schema_snapshot --ignored\n\n");

    // Tables and columns
    let mut current_table = String::new();
    for (table, column, data_type, default, nullable, udt_name) in &tables {
        if table != &current_table {
            if !current_table.is_empty() {
                output.push_str(");\n\n");
            }
            output.push_str(&format!("CREATE TABLE {} (\n", table));
            current_table = table.clone();
        } else {
            output.push_str(",\n");
        }

        let type_str = if udt_name.is_empty() || udt_name == data_type {
            data_type.to_uppercase()
        } else {
            udt_name.to_uppercase()
        };

        let null_str = if *nullable == 0 { " NOT NULL" } else { "" };
        let default_str = if default.is_empty() {
            String::new()
        } else {
            format!(" DEFAULT {}", default)
        };

        output.push_str(&format!("    {} {}{}{}", column, type_str, null_str, default_str));
    }
    if !current_table.is_empty() {
        output.push_str("\n);\n\n");
    }

    // Indexes
    output.push_str("-- Indexes\n");
    for (table, name, def) in &indexes {
        output.push_str(&format!("-- {}.{}\n{}\n\n", table, name, def));
    }

    // Constraints
    output.push_str("-- Constraints\n");
    for (table, name, ctype) in &constraints {
        output.push_str(&format!("-- {}: {} ({})\n", table, name, ctype));
    }

    output
}

/// Compares current schema against the committed snapshot.
#[shared_runtime_test]
async fn test_schema_matches_snapshot() {
    let db = isolated_db().await;
    let current_schema = extract_schema(db.pool()).await;

    // Read expected snapshot
    let snapshot = match std::fs::read_to_string(SCHEMA_SNAPSHOT_PATH) {
        Ok(content) => content,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            panic!(
                "SCHEMA SNAPSHOT MISSING\n\
                 No schema snapshot found at: {}\n\n\
                 Generate it by running:\n\
                 cargo test -- generate_schema_snapshot --ignored\n\n\
                 Then commit the generated file.",
                SCHEMA_SNAPSHOT_PATH
            );
        }
        Err(e) => panic!("Failed to read schema snapshot: {}", e),
    };

    if current_schema != snapshot {
        // Find differences
        let current_lines: Vec<_> = current_schema.lines().collect();
        let snapshot_lines: Vec<_> = snapshot.lines().collect();

        let mut diff_output = String::new();
        diff_output.push_str("SCHEMA DRIFT DETECTED\n\n");
        diff_output.push_str("The database schema does not match the committed snapshot.\n");
        diff_output.push_str("This may indicate:\n");
        diff_output.push_str("  1. A migration was added but snapshot wasn't regenerated\n");
        diff_output.push_str("  2. Unintentional schema changes\n\n");
        diff_output.push_str("Differences:\n");

        // Simple line-by-line diff
        let max_lines = std::cmp::max(current_lines.len(), snapshot_lines.len());
        for i in 0..max_lines {
            let current = current_lines.get(i).unwrap_or(&"<missing>");
            let expected = snapshot_lines.get(i).unwrap_or(&"<missing>");
            if current != expected {
                diff_output.push_str(&format!("Line {}:\n", i + 1));
                diff_output.push_str(&format!("  - {}\n", expected));
                diff_output.push_str(&format!("  + {}\n", current));
            }
        }

        diff_output.push_str("\nTo update the snapshot (after verifying changes are intentional):\n");
        diff_output.push_str("  cargo test -- generate_schema_snapshot --ignored\n");

        panic!("{}", diff_output);
    }
}

/// Generates a new schema snapshot. Run when migrations intentionally change schema.
#[shared_runtime_test]
#[ignore] // Always ignored - run explicitly when needed
async fn generate_schema_snapshot() {
    let db = isolated_db().await;
    let schema = extract_schema(db.pool()).await;

    // Ensure snapshots directory exists
    let snapshot_dir = std::path::Path::new(SCHEMA_SNAPSHOT_PATH).parent().unwrap();
    std::fs::create_dir_all(snapshot_dir).expect("Failed to create snapshots directory");

    std::fs::write(SCHEMA_SNAPSHOT_PATH, &schema).expect("Failed to write schema snapshot");

    println!("Schema snapshot written to: {}", SCHEMA_SNAPSHOT_PATH);
    println!("Review the changes and commit the updated snapshot.");
}
