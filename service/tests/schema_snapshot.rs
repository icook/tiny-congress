//! Schema snapshot testing using insta.
//!
//! This test compares the current database schema against a committed snapshot
//! to detect unintentional schema drift. When migrations intentionally change
//! the schema, run `cargo insta review` to update the snapshot.
//!
//! Run with: `cargo test schema_snapshot`
//! Update snapshot: `cargo insta review`

mod common;

use common::migration_helpers::load_migrator;
use common::test_db::empty_db;
use tc_test_macros::shared_runtime_test;

/// Extracts the current schema from the database in a normalized format.
async fn extract_schema(pool: &sqlx::PgPool) -> String {
    // Get all table definitions
    let tables: Vec<(String, String, String, String, i32, String)> = sqlx::query_as(
        r#"
        SELECT
            t.table_name,
            c.column_name,
            c.data_type,
            COALESCE(c.column_default, ''),
            CASE WHEN c.is_nullable = 'NO' THEN 0 ELSE 1 END as nullable,
            COALESCE(c.udt_name, '')
        FROM information_schema.tables t
        JOIN information_schema.columns c ON t.table_name = c.table_name
        WHERE t.table_schema = 'public'
        AND t.table_type = 'BASE TABLE'
        AND t.table_name NOT LIKE '_sqlx%'
        ORDER BY t.table_name, c.ordinal_position
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract schema");

    // Get all indexes
    let indexes: Vec<(String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tablename,
            indexname,
            indexdef
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename NOT LIKE '_sqlx%'
        ORDER BY tablename, indexname
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract indexes");

    // Get all constraints (excluding FK which we handle separately)
    let constraints: Vec<(String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tc.table_name,
            tc.constraint_name,
            tc.constraint_type
        FROM information_schema.table_constraints tc
        WHERE tc.table_schema = 'public'
        AND tc.table_name NOT LIKE '_sqlx%'
        AND tc.constraint_type != 'FOREIGN KEY'
        ORDER BY tc.table_name, tc.constraint_name
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract constraints");

    // Get foreign key details
    let foreign_keys: Vec<(String, String, String, String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tc.table_name,
            kcu.column_name,
            ccu.table_name AS referenced_table,
            ccu.column_name AS referenced_column,
            rc.update_rule,
            rc.delete_rule
        FROM information_schema.table_constraints tc
        JOIN information_schema.key_column_usage kcu
            ON tc.constraint_name = kcu.constraint_name
            AND tc.table_schema = kcu.table_schema
        JOIN information_schema.constraint_column_usage ccu
            ON tc.constraint_name = ccu.constraint_name
            AND tc.table_schema = ccu.table_schema
        JOIN information_schema.referential_constraints rc
            ON tc.constraint_name = rc.constraint_name
            AND tc.table_schema = rc.constraint_schema
        WHERE tc.constraint_type = 'FOREIGN KEY'
        AND tc.table_schema = 'public'
        AND tc.table_name NOT LIKE '_sqlx%'
        ORDER BY tc.table_name, kcu.column_name
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract foreign keys");

    // Build normalized schema representation
    let mut output = String::new();
    output.push_str("-- Schema Snapshot\n");
    output.push_str("-- Generated by schema_snapshot test\n");
    output.push_str("-- Update: cargo insta review\n\n");

    // Tables and columns
    let mut current_table = String::new();
    for (table, column, data_type, default, nullable, udt_name) in &tables {
        if table != &current_table {
            if !current_table.is_empty() {
                output.push_str(");\n\n");
            }
            output.push_str(&format!("CREATE TABLE {} (\n", table));
            current_table = table.clone();
        } else {
            output.push_str(",\n");
        }

        let type_str = if udt_name.is_empty() || udt_name == data_type {
            data_type.to_uppercase()
        } else {
            udt_name.to_uppercase()
        };

        let null_str = if *nullable == 0 { " NOT NULL" } else { "" };
        let default_str = if default.is_empty() {
            String::new()
        } else {
            format!(" DEFAULT {}", default)
        };

        output.push_str(&format!(
            "    {} {}{}{}",
            column, type_str, null_str, default_str
        ));
    }
    if !current_table.is_empty() {
        output.push_str("\n);\n\n");
    }

    // Indexes
    output.push_str("-- Indexes\n");
    for (table, name, def) in &indexes {
        output.push_str(&format!("-- {}.{}\n{}\n\n", table, name, def));
    }

    // Foreign Keys
    if !foreign_keys.is_empty() {
        output.push_str("-- Foreign Keys\n");
        for (table, column, ref_table, ref_column, update_rule, delete_rule) in &foreign_keys {
            output.push_str(&format!(
                "-- {}.{} -> {}.{} (ON UPDATE {}, ON DELETE {})\n",
                table, column, ref_table, ref_column, update_rule, delete_rule
            ));
        }
        output.push('\n');
    }

    // Constraints (non-FK)
    output.push_str("-- Constraints\n");
    for (table, name, ctype) in &constraints {
        output.push_str(&format!("-- {}: {} ({})\n", table, name, ctype));
    }

    output
}

/// Compares current schema against the committed snapshot using insta.
///
/// Uses `empty_db()` + migrations (not `isolated_db()`) so the snapshot
/// reflects the production schema only, without test-bootstrapped tables
/// like `test_items`.
#[shared_runtime_test]
async fn test_schema_matches_snapshot() {
    let db = empty_db().await;
    let migrator = load_migrator().await;
    migrator
        .run(db.pool())
        .await
        .expect("Failed to run migrations");
    let current_schema = extract_schema(db.pool()).await;

    insta::assert_snapshot!(current_schema);
}
