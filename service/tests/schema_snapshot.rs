//! Schema snapshot testing using insta.
//!
//! This test compares the current database schema against a committed snapshot
//! to detect unintentional schema drift. When migrations intentionally change
//! the schema, run `cargo insta review` to update the snapshot.
//!
//! Run with: `cargo test schema_snapshot`
//! Update snapshot: `cargo insta review`

mod common;

use common::test_db::isolated_db;
use tc_test_macros::shared_runtime_test;

/// Extracts the current schema from the database in a normalized format.
async fn extract_schema(pool: &sqlx::PgPool) -> String {
    // Get all table definitions
    let tables: Vec<(String, String, String, String, i32, String)> = sqlx::query_as(
        r#"
        SELECT
            t.table_name,
            c.column_name,
            c.data_type,
            COALESCE(c.column_default, ''),
            CASE WHEN c.is_nullable = 'NO' THEN 0 ELSE 1 END as nullable,
            COALESCE(c.udt_name, '')
        FROM information_schema.tables t
        JOIN information_schema.columns c ON t.table_name = c.table_name
        WHERE t.table_schema = 'public'
        AND t.table_type = 'BASE TABLE'
        AND t.table_name NOT LIKE '_sqlx%'
        ORDER BY t.table_name, c.ordinal_position
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract schema");

    // Get all indexes
    let indexes: Vec<(String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tablename,
            indexname,
            indexdef
        FROM pg_indexes
        WHERE schemaname = 'public'
        AND tablename NOT LIKE '_sqlx%'
        ORDER BY tablename, indexname
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract indexes");

    // Get all constraints
    let constraints: Vec<(String, String, String)> = sqlx::query_as(
        r#"
        SELECT
            tc.table_name,
            tc.constraint_name,
            tc.constraint_type
        FROM information_schema.table_constraints tc
        WHERE tc.table_schema = 'public'
        AND tc.table_name NOT LIKE '_sqlx%'
        ORDER BY tc.table_name, tc.constraint_name
        "#,
    )
    .fetch_all(pool)
    .await
    .expect("Failed to extract constraints");

    // Build normalized schema representation
    let mut output = String::new();
    output.push_str("-- Schema Snapshot\n");
    output.push_str("-- Generated by schema_snapshot test\n");
    output.push_str("-- Update: cargo insta review\n\n");

    // Tables and columns
    let mut current_table = String::new();
    for (table, column, data_type, default, nullable, udt_name) in &tables {
        if table != &current_table {
            if !current_table.is_empty() {
                output.push_str(");\n\n");
            }
            output.push_str(&format!("CREATE TABLE {} (\n", table));
            current_table = table.clone();
        } else {
            output.push_str(",\n");
        }

        let type_str = if udt_name.is_empty() || udt_name == data_type {
            data_type.to_uppercase()
        } else {
            udt_name.to_uppercase()
        };

        let null_str = if *nullable == 0 { " NOT NULL" } else { "" };
        let default_str = if default.is_empty() {
            String::new()
        } else {
            format!(" DEFAULT {}", default)
        };

        output.push_str(&format!(
            "    {} {}{}{}",
            column, type_str, null_str, default_str
        ));
    }
    if !current_table.is_empty() {
        output.push_str("\n);\n\n");
    }

    // Indexes
    output.push_str("-- Indexes\n");
    for (table, name, def) in &indexes {
        output.push_str(&format!("-- {}.{}\n{}\n\n", table, name, def));
    }

    // Constraints
    output.push_str("-- Constraints\n");
    for (table, name, ctype) in &constraints {
        output.push_str(&format!("-- {}: {} ({})\n", table, name, ctype));
    }

    output
}

/// Compares current schema against the committed snapshot using insta.
#[shared_runtime_test]
async fn test_schema_matches_snapshot() {
    let db = isolated_db().await;
    let current_schema = extract_schema(db.pool()).await;

    insta::assert_snapshot!(current_schema);
}
