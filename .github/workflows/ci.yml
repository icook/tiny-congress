name: CI

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - '**'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.sha }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io/${{ github.repository }}

jobs:
  # ============================================================
  # JOB 0: Lint Rust formatting
  # ============================================================
  lint:
    name: Lint Rust formatting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Check formatting
        working-directory: service
        run: cargo fmt --all -- --check

  # ============================================================
  # JOB 1: Build all container images in parallel
  # ============================================================
  build-images:
    name: Build ${{ matrix.image }}
    needs: lint
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - image: tc-api-dev
            context: ./service
            dockerfile: service/Dockerfile.dev
          - image: tc-ui-dev
            context: ./web
            dockerfile: web/Dockerfile.dev
          - image: postgres
            context: .
            dockerfile: dockerfiles/Dockerfile.postgres
    outputs:
      tc-api-dev-tag: ${{ steps.meta.outputs.tc-api-dev-tag }}
      tc-ui-dev-tag: ${{ steps.meta.outputs.tc-ui-dev-tag }}
      postgres-tag: ${{ steps.meta.outputs.postgres-tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: tags
        run: |
          ref="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
          branch="${ref//[^a-zA-Z0-9_.-]/-}"
          branch="${branch,,}"
          echo "branch_slug=${branch}" >> "$GITHUB_OUTPUT"
          echo "sha_tag=${{ env.REGISTRY }}/${{ matrix.image }}:${{ github.sha }}" >> "$GITHUB_OUTPUT"
          echo "branch_tag=${{ env.REGISTRY }}/${{ matrix.image }}:branch-${branch}" >> "$GITHUB_OUTPUT"

      - name: Build and push ${{ matrix.image }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          platforms: linux/amd64
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          tags: |
            ${{ steps.tags.outputs.sha_tag }}
            ${{ steps.tags.outputs.branch_tag }}
          cache-from: |
            type=gha,scope=${{ matrix.image }}
            type=registry,ref=${{ env.REGISTRY }}/${{ matrix.image }}:cache
          cache-to: |
            type=gha,scope=${{ matrix.image }},mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ matrix.image }}:cache,mode=max

      - name: Export image metadata
        id: meta
        run: |
          echo "${{ matrix.image }}-tag=${{ steps.tags.outputs.sha_tag }}" >> "$GITHUB_OUTPUT"

  # ============================================================
  # JOB 2: Aggregate image metadata from matrix
  # ============================================================
  collect-image-metadata:
    name: Collect image metadata
    runs-on: ubuntu-latest
    needs: build-images
    outputs:
      artifacts_json: ${{ steps.generate.outputs.artifacts_json }}
    steps:
      - name: Generate Skaffold artifacts JSON
        id: generate
        run: |
          artifacts=$(cat <<'EOF'
          {
            "builds": [
              {"imageName": "tc-api-dev", "tag": "${{ env.REGISTRY }}/tc-api-dev:${{ github.sha }}"},
              {"imageName": "tc-ui-dev", "tag": "${{ env.REGISTRY }}/tc-ui-dev:${{ github.sha }}"},
              {"imageName": "postgres", "tag": "${{ env.REGISTRY }}/postgres:${{ github.sha }}"}
            ]
          }
          EOF
          )
          artifacts_escaped=$(echo "$artifacts" | jq -c .)
          echo "artifacts_json=${artifacts_escaped}" >> "$GITHUB_OUTPUT"
        env:
          REGISTRY: ghcr.io/${{ github.repository }}

  # ============================================================
  # JOB 3: Run Skaffold test/deploy/verify
  # ============================================================
  skaffold-verify:
    name: Skaffold verify
    runs-on: ubuntu-latest
    needs: collect-image-metadata
    permissions:
      contents: read
      packages: read
      checks: write
    env:
      SKAFFOLD_DEFAULT_REPO: ghcr.io/${{ github.repository }}
      SKAFFOLD_PROFILE: ci
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Set up KinD cluster
        uses: helm/kind-action@v1.10.0
        with:
          version: v0.22.0
          kubectl_version: v1.30.0
          cluster_name: skaffold-ci

      - name: Cache Skaffold
        id: cache-skaffold
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/skaffold
          key: skaffold-v2.16.1

      - name: Install Skaffold
        if: steps.cache-skaffold.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          SKAFFOLD_VERSION=v2.16.1
          curl -fsSL -o skaffold https://storage.googleapis.com/skaffold/releases/${SKAFFOLD_VERSION}/skaffold-linux-amd64
          sudo install skaffold /usr/local/bin/skaffold

      - name: Verify Skaffold installation
        run: skaffold version

      - name: Show cluster info
        run: |
          kubectl version --client=true
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure registry access for KinD
        run: |
          set -euo pipefail
          kubectl create secret docker-registry ghcr-cred \
            --namespace default \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}" \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl patch serviceaccount default \
            -n default \
            --type merge \
            -p '{"imagePullSecrets":[{"name":"ghcr-cred"}]}'

      - name: Write Skaffold artifacts file
        id: artifacts
        run: |
          set -euo pipefail
          artifacts_file="${RUNNER_TEMP}/skaffold-artifacts.json"
          echo '${{ needs.collect-image-metadata.outputs.artifacts_json }}' > "$artifacts_file"
          echo "Artifacts file contents:"
          cat "$artifacts_file"
          echo "file=${artifacts_file}" >> "$GITHUB_OUTPUT"

      - name: Prepare test output directories
        run: |
          mkdir -p web/reports web/test-results web/coverage/playwright service/coverage
          rm -f service/coverage/backend-unit.lcov service/coverage/backend-integration.lcov

      - name: Run Skaffold tests
        run: |
          set -euo pipefail
          skaffold test -p ${SKAFFOLD_PROFILE} --build-artifacts "${{ steps.artifacts.outputs.file }}"

      - name: Publish Playwright test report
        if: always() && hashFiles('web/reports/playwright.xml') != ''
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: web/reports/playwright.xml
          report_individual_runs: true
          check_name: Playwright E2E
          comment_mode: off

      - name: Upload Playwright coverage
        if: always() && hashFiles('web/coverage/playwright/lcov.info') != ''
        uses: actions/upload-artifact@v4
        with:
          name: playwright-coverage
          path: web/coverage/playwright/lcov.info

      - name: Summarize Playwright coverage
        if: always() && hashFiles('web/coverage/playwright/coverage-summary.json') != ''
        run: |
          node - <<'EOF'
          import fs from 'node:fs';
          import path from 'node:path';

          const summaryPath = path.join(process.cwd(), 'web/coverage/playwright/coverage-summary.json');
          const summary = JSON.parse(fs.readFileSync(summaryPath, 'utf8')).total;
          const rows = [
            ['Lines', `${summary.lines.pct}%`, summary.lines.covered, summary.lines.total],
            ['Statements', `${summary.statements.pct}%`, summary.statements.covered, summary.statements.total],
            ['Functions', `${summary.functions.pct}%`, summary.functions.covered, summary.functions.total],
            ['Branches', `${summary.branches.pct}%`, summary.branches.covered, summary.branches.total],
          ].map((cells) => `| ${cells.join(' | ')} |`).join('\n');

          const header = '| Metric | Pct | Covered | Total |';
          const separator = '| --- | --- | --- | --- |';
          const body = `### Playwright coverage\n${header}\n${separator}\n${rows}\n`;
          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, body);
          EOF

      - name: Upload Playwright artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts
          if-no-files-found: warn
          path: |
            web/test-results
            web/reports/playwright.xml
            web/coverage/playwright

      - name: Deploy with Skaffold
        run: |
          set -euo pipefail
          skaffold deploy -p ${SKAFFOLD_PROFILE} --status-check=true --build-artifacts "${{ steps.artifacts.outputs.file }}"

      - name: Run Skaffold verify
        run: |
          set -euo pipefail
          log_file="${RUNNER_TEMP}/skaffold-verify.log"

          if skaffold verify -p ${SKAFFOLD_PROFILE} --build-artifacts "${{ steps.artifacts.outputs.file }}" | tee "$log_file"; then
            status=0
          else
            status=$?
          fi

          start_marker="BEGIN_INTEGRATION_LCOV"
          end_marker="END_INTEGRATION_LCOV"
          mkdir -p service/coverage

          if grep -q "$start_marker" "$log_file"; then
            payload=$(awk "/$start_marker/{flag=1;next}/$end_marker/{flag=0}flag" "$log_file" | tr -d '\n' || true)
            if [ -n "$payload" ]; then
              echo "$payload" | base64 --decode > service/coverage/backend-integration.lcov
              echo "Integration coverage written to service/coverage/backend-integration.lcov"
            else
              echo "Integration coverage markers found but payload was empty" >&2
            fi
          else
            echo "Integration coverage markers not found in Skaffold verify output" >&2
          fi

          exit $status

      - name: Upload Rust coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v5
        with:
          files: ./service/coverage/backend-unit.lcov,./service/coverage/backend-integration.lcov
          flags: rust
          name: rust-coverage
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: false

      - name: Dump diagnostics on failure
        if: failure()
        run: |
          echo '--- Pods ---'
          kubectl get pods -A -o wide || true
          echo '--- Services ---'
          kubectl get svc -A || true
          echo '--- Events ---'
          kubectl get events -A --sort-by=.lastTimestamp || true
          echo '--- All Resources ---'
          kubectl get all -n default || true
