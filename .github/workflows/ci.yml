name: CI

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - '**'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.sha }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io/${{ github.repository }}

jobs:
  # ============================================================
  # JOB: Validate agent compliance block in PR description
  # ============================================================
  agent-compliance:
    name: Agent compliance check
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check agent compliance block
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: ./.github/scripts/check-agent-compliance.sh

  # ============================================================
  # JOB 0: Lint Rust formatting
  # ============================================================
  lint:
    name: Lint Rust formatting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: service -> target

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Lint backend
        run: just lint-backend

  # ============================================================
  # JOB 0b: Lint web
  # ============================================================
  lint-web:
    name: Lint web
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version-file: web/.nvmrc
          cache: yarn
          cache-dependency-path: web/yarn.lock

      - name: Enable corepack
        run: corepack enable

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Install dependencies
        run: just install-frontend

      - name: Run Linters
        run: just lint-frontend

  # ============================================================
  # JOB 0c: Verify GraphQL codegen is up-to-date
  # ============================================================
  codegen-check:
    name: Check GraphQL codegen
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: service -> target

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version-file: web/.nvmrc
          cache: yarn
          cache-dependency-path: web/yarn.lock

      - name: Enable corepack
        run: corepack enable

      - name: Install just
        uses: extractions/setup-just@v2

      - name: Install frontend dependencies
        run: just install-frontend

      - name: Run codegen
        run: just codegen

      - name: Check for uncommitted changes
        run: |
          if ! git diff --quiet web/schema.graphql web/src/api/generated/; then
            echo "::error::GraphQL codegen is out of date. Run 'just codegen' and commit the changes."
            git diff web/schema.graphql web/src/api/generated/
            exit 1
          fi
          echo "âœ“ GraphQL codegen is up to date"

  # ============================================================
  # JOB 1: Build all container images in parallel
  # ============================================================
  build-images:
    name: Build ${{ matrix.image }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - image: tc-api-release
            context: ./service
            dockerfile: service/Dockerfile
          - image: tc-ui-release
            context: ./web
            dockerfile: web/Dockerfile
          - image: postgres
            context: .
            dockerfile: dockerfiles/Dockerfile.postgres
    outputs:
      tc-api-release-tag: ${{ steps.meta.outputs.tc-api-release-tag }}
      tc-ui-release-tag: ${{ steps.meta.outputs.tc-ui-release-tag }}
      postgres-tag: ${{ steps.meta.outputs.postgres-tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute tags
        id: tags
        run: |
          ref="${GITHUB_HEAD_REF:-$GITHUB_REF_NAME}"
          branch="${ref//[^a-zA-Z0-9_.-]/-}"
          branch="${branch,,}"
          echo "branch_slug=${branch}" >> "$GITHUB_OUTPUT"
          echo "sha_tag=${{ env.REGISTRY }}/${{ matrix.image }}:${{ github.sha }}" >> "$GITHUB_OUTPUT"
          echo "branch_tag=${{ env.REGISTRY }}/${{ matrix.image }}:branch-${branch}" >> "$GITHUB_OUTPUT"

      - name: Build and push ${{ matrix.image }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          platforms: linux/amd64
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          tags: |
            ${{ steps.tags.outputs.sha_tag }}
            ${{ steps.tags.outputs.branch_tag }}
          cache-from: |
            type=gha,scope=${{ matrix.image }}
            type=registry,ref=${{ env.REGISTRY }}/${{ matrix.image }}:cache
          cache-to: |
            type=gha,scope=${{ matrix.image }},mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ matrix.image }}:cache,mode=max

      - name: Export image metadata
        id: meta
        run: |
          echo "${{ matrix.image }}-tag=${{ steps.tags.outputs.sha_tag }}" >> "$GITHUB_OUTPUT"

  # ============================================================
  # JOB 2a: Run Skaffold tests (container structure tests)
  # ============================================================
  container-tests:
    name: Container structure tests
    runs-on: ubuntu-latest
    needs:
      - build-images
    permissions:
      contents: read
      packages: read
    env:
      SKAFFOLD_DEFAULT_REPO: ghcr.io/${{ github.repository }}
      SKAFFOLD_PROFILE: ci
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache Skaffold
        id: cache-skaffold
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/skaffold
          key: skaffold-v${{ hashFiles('.skaffold-version') }}

      - name: Install Skaffold
        if: steps.cache-skaffold.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          SKAFFOLD_VERSION=v$(cat .skaffold-version)
          curl -fsSL -o skaffold https://storage.googleapis.com/skaffold/releases/${SKAFFOLD_VERSION}/skaffold-linux-amd64
          sudo install skaffold /usr/local/bin/skaffold

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Write Skaffold artifacts file
        id: artifacts
        run: |
          set -euo pipefail
          artifacts_file="${RUNNER_TEMP}/skaffold-artifacts.json"
          cat > "$artifacts_file" <<'EOF'
          {
            "builds": [
              {"imageName": "tc-api-release", "tag": "${{ env.REGISTRY }}/tc-api-release:${{ github.sha }}"},
              {"imageName": "tc-ui-release", "tag": "${{ env.REGISTRY }}/tc-ui-release:${{ github.sha }}"},
              {"imageName": "postgres", "tag": "${{ env.REGISTRY }}/postgres:${{ github.sha }}"}
            ]
          }
          EOF
          echo "file=${artifacts_file}" >> "$GITHUB_OUTPUT"

      - name: Run Skaffold tests
        run: |
          set -euo pipefail
          skaffold test -p ${SKAFFOLD_PROFILE} --build-artifacts "${{ steps.artifacts.outputs.file }}"

  # ============================================================
  # JOB 2b: Backend integration tests
  # ============================================================
  backend-integration:
    name: Backend integration tests
    runs-on: ubuntu-latest
    needs:
      - build-images
      - lint
    permissions:
      contents: read
      packages: read
    env:
      SKAFFOLD_DEFAULT_REPO: ghcr.io/${{ github.repository }}
      SKAFFOLD_PROFILE: ci
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install KinD tooling
        uses: helm/kind-action@v1.13.0
        with:
          install_only: true
          cluster_name: backend-ci

      - name: Start KinD cluster in background
        run: |
          set -euo pipefail
          KIND_LOG="${RUNNER_TEMP}/kind.log"
          echo "KIND_LOG=${KIND_LOG}" >> "$GITHUB_ENV"
          echo "Starting KinD cluster backend-ci (logs: ${KIND_LOG})"
          kind create cluster --name backend-ci --wait 0s >"${KIND_LOG}" 2>&1 &

      - name: Cache Skaffold
        id: cache-skaffold
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/skaffold
          key: skaffold-v${{ hashFiles('.skaffold-version') }}

      - name: Install Skaffold
        if: steps.cache-skaffold.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          SKAFFOLD_VERSION=v$(cat .skaffold-version)
          curl -fsSL -o skaffold https://storage.googleapis.com/skaffold/releases/${SKAFFOLD_VERSION}/skaffold-linux-amd64
          sudo install skaffold /usr/local/bin/skaffold

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: service -> target

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Write Skaffold artifacts file
        id: artifacts
        run: |
          set -euo pipefail
          artifacts_file="${RUNNER_TEMP}/skaffold-artifacts.json"
          cat > "$artifacts_file" <<'EOF'
          {
            "builds": [
              {"imageName": "tc-api-release", "tag": "${{ env.REGISTRY }}/tc-api-release:${{ github.sha }}"},
              {"imageName": "tc-ui-release", "tag": "${{ env.REGISTRY }}/tc-ui-release:${{ github.sha }}"},
              {"imageName": "postgres", "tag": "${{ env.REGISTRY }}/postgres:${{ github.sha }}"}
            ]
          }
          EOF
          echo "file=${artifacts_file}" >> "$GITHUB_OUTPUT"

      - name: Wait for KinD readiness
        run: |
          set -euo pipefail
          : "${KIND_LOG:?KIND_LOG not set}"
          echo "Waiting for cluster API to become available..."
          if ! timeout 180 bash -c 'until kubectl cluster-info --context kind-backend-ci >/dev/null 2>&1; do sleep 5; done'; then
            echo "KinD did not finish starting in time; dumping logs."
            cat "${KIND_LOG}" || true
            exit 1
          fi
          kubectl version --client=true
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: Configure registry access for KinD
        run: |
          set -euo pipefail
          kubectl create secret docker-registry ghcr-cred \
            --namespace default \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}" \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl patch serviceaccount default \
            -n default \
            --type merge \
            -p '{"imagePullSecrets":[{"name":"ghcr-cred"}]}'

      - name: Deploy with Skaffold
        run: |
          set -euo pipefail
          skaffold deploy -p ${SKAFFOLD_PROFILE} --status-check=true \
            --build-artifacts "${{ steps.artifacts.outputs.file }}"

      - name: Prepare coverage directory
        run: |
          mkdir -p service/coverage
          rm -f service/coverage/backend-unit.lcov service/coverage/backend-integration.lcov

      - name: Run Rust integration tests
        run: |
          set -euo pipefail
          # Ensure Postgres is ready before port-forwarding
          kubectl wait --for=condition=available --timeout=180s deployment/postgres

          # Port-forward PostgreSQL
          kubectl port-forward svc/postgres 5432:5432 &
          PF_PG_PID=$!
          sleep 3

          # Run integration tests
          cd service
          DATABASE_URL=postgres://postgres:postgres@localhost:5432/prioritization \
            ARTIFACTS_DIR=coverage \
            ./bin/integration-coverage.sh

          # Cleanup
          kill $PF_PG_PID 2>/dev/null || true

      - name: Upload Rust coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rust-coverage
          if-no-files-found: warn
          path: |
            service/coverage/backend-unit.lcov
            service/coverage/backend-integration.lcov

      - name: Summarize Rust coverage
        if: always()
        run: |
          sudo apt-get update && sudo apt-get install -y lcov
          {
            echo "### Rust coverage"
            echo ""
            for file in service/coverage/backend-unit.lcov service/coverage/backend-integration.lcov; do
              if [ -f "$file" ]; then
                echo "#### $(basename $file .lcov)"
                lcov --summary "$file" 2>&1 | grep -E "lines\.|functions\." || true
                echo ""
              fi
            done
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Dump diagnostics on failure
        if: failure()
        run: |
          echo '--- Pods ---'
          kubectl get pods -A -o wide || true
          echo '--- Services ---'
          kubectl get svc -A || true
          echo '--- Events ---'
          kubectl get events -A --sort-by=.lastTimestamp || true
          echo '--- All Resources ---'
          kubectl get all -n default || true

  # ============================================================
  # JOB 2c: Playwright E2E tests
  # ============================================================
  e2e-tests:
    name: Playwright E2E tests
    runs-on: ubuntu-latest
    needs:
      - build-images
      - lint-web
      - codegen-check
    permissions:
      contents: read
      packages: read
      checks: write
    env:
      SKAFFOLD_DEFAULT_REPO: ghcr.io/${{ github.repository }}
      SKAFFOLD_PROFILE: ci
      PLAYWRIGHT_BROWSERS_PATH: ${{ github.workspace }}/.cache/ms-playwright
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install KinD tooling
        uses: helm/kind-action@v1.13.0
        with:
          install_only: true
          cluster_name: e2e-ci

      - name: Start KinD cluster in background
        run: |
          set -euo pipefail
          KIND_LOG="${RUNNER_TEMP}/kind.log"
          echo "KIND_LOG=${KIND_LOG}" >> "$GITHUB_ENV"
          echo "Starting KinD cluster e2e-ci (logs: ${KIND_LOG})"
          kind create cluster --name e2e-ci --wait 0s >"${KIND_LOG}" 2>&1 &

      - name: Cache Skaffold
        id: cache-skaffold
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/skaffold
          key: skaffold-v${{ hashFiles('.skaffold-version') }}

      - name: Install Skaffold
        if: steps.cache-skaffold.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          SKAFFOLD_VERSION=v$(cat .skaffold-version)
          curl -fsSL -o skaffold https://storage.googleapis.com/skaffold/releases/${SKAFFOLD_VERSION}/skaffold-linux-amd64
          sudo install skaffold /usr/local/bin/skaffold

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version-file: web/.nvmrc
          cache: yarn
          cache-dependency-path: web/yarn.lock

      - name: Enable corepack
        run: corepack enable

      - name: Install web dependencies
        working-directory: web
        run: yarn install --immutable

      - name: Cache Playwright browsers
        id: cache-playwright
        uses: actions/cache@v4
        with:
          path: ${{ env.PLAYWRIGHT_BROWSERS_PATH }}
          key: playwright-${{ runner.os }}-${{ hashFiles('web/yarn.lock') }}

      - name: Install Playwright browsers
        working-directory: web
        run: yarn playwright install --with-deps chromium

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Write Skaffold artifacts file
        id: artifacts
        run: |
          set -euo pipefail
          artifacts_file="${RUNNER_TEMP}/skaffold-artifacts.json"
          cat > "$artifacts_file" <<'EOF'
          {
            "builds": [
              {"imageName": "tc-api-release", "tag": "${{ env.REGISTRY }}/tc-api-release:${{ github.sha }}"},
              {"imageName": "tc-ui-release", "tag": "${{ env.REGISTRY }}/tc-ui-release:${{ github.sha }}"},
              {"imageName": "postgres", "tag": "${{ env.REGISTRY }}/postgres:${{ github.sha }}"}
            ]
          }
          EOF
          echo "file=${artifacts_file}" >> "$GITHUB_OUTPUT"

      - name: Wait for KinD readiness
        run: |
          set -euo pipefail
          : "${KIND_LOG:?KIND_LOG not set}"
          echo "Waiting for cluster API to become available..."
          if ! timeout 180 bash -c 'until kubectl cluster-info --context kind-e2e-ci >/dev/null 2>&1; do sleep 5; done'; then
            echo "KinD did not finish starting in time; dumping logs."
            cat "${KIND_LOG}" || true
            exit 1
          fi
          kubectl version --client=true
          kubectl cluster-info
          kubectl get nodes -o wide

      - name: Configure registry access for KinD
        run: |
          set -euo pipefail
          kubectl create secret docker-registry ghcr-cred \
            --namespace default \
            --docker-server=ghcr.io \
            --docker-username="${{ github.actor }}" \
            --docker-password="${{ secrets.GITHUB_TOKEN }}" \
            --dry-run=client -o yaml | kubectl apply -f -

          kubectl patch serviceaccount default \
            -n default \
            --type merge \
            -p '{"imagePullSecrets":[{"name":"ghcr-cred"}]}'

      - name: Deploy with Skaffold
        run: |
          set -euo pipefail
          skaffold deploy -p ${SKAFFOLD_PROFILE} --status-check=true \
            --build-artifacts "${{ steps.artifacts.outputs.file }}"

      - name: Prepare test output directories
        run: |
          mkdir -p web/reports web/test-results web/coverage/playwright

      - name: Build instrumented frontend for E2E tests
        working-directory: web
        run: PLAYWRIGHT_COVERAGE=1 yarn build

      - name: Run Playwright E2E tests
        working-directory: web
        env:
          CI: true
          PLAYWRIGHT_COVERAGE: "1"
          PLAYWRIGHT_BASE_URL: http://localhost:5173
          PLAYWRIGHT_API_URL: http://localhost:8080/graphql
        run: |
          set -euo pipefail

          # Port-forward API from cluster
          kubectl port-forward service/tc 8080:8080 &
          PF_API_PID=$!
          timeout 60 bash -c 'until curl -sf http://localhost:8080/health >/dev/null; do sleep 1; done'

          # Start local preview server with instrumented build
          yarn preview --host 0.0.0.0 --port 5173 --strictPort &
          PREVIEW_PID=$!
          timeout 60 bash -c 'until curl -sf http://localhost:5173 >/dev/null; do sleep 1; done'

          # Run tests
          node ./scripts/reset-playwright-coverage.mjs
          yarn playwright:test || TEST_EXIT=$?
          [ -d .nyc_output ] && yarn playwright:report || true

          # Cleanup
          kill $PREVIEW_PID $PF_API_PID 2>/dev/null || true
          exit ${TEST_EXIT:-0}

      - name: Publish Playwright test report
        if: always() && hashFiles('web/reports/playwright.xml') != ''
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: web/reports/playwright.xml
          report_individual_runs: true
          check_name: Playwright E2E
          comment_mode: off

      - name: Summarize Playwright coverage
        if: always()
        working-directory: web
        run: |
          if [ -d .nyc_output ]; then
            {
              echo "### Playwright coverage"
              echo '```'
              npx nyc report --reporter=text-summary 2>/dev/null || true
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Upload Playwright artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-artifacts
          if-no-files-found: warn
          path: |
            web/test-results
            web/reports/playwright.xml
            web/playwright-report
            web/coverage/playwright

      - name: Dump diagnostics on failure
        if: failure()
        run: |
          echo '--- Pods ---'
          kubectl get pods -A -o wide || true
          echo '--- Services ---'
          kubectl get svc -A || true
          echo '--- Events ---'
          kubectl get events -A --sort-by=.lastTimestamp || true
          echo '--- All Resources ---'
          kubectl get all -n default || true

  # ============================================================
  # JOB 2d: Bundle size analysis (no cluster needed)
  # ============================================================
  bundle-analysis:
    name: Bundle size analysis
    runs-on: ubuntu-latest
    needs:
      - lint-web
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version-file: web/.nvmrc
          cache: yarn
          cache-dependency-path: web/yarn.lock

      - name: Enable corepack
        run: corepack enable

      - name: Install web dependencies
        working-directory: web
        run: yarn install --immutable

      - name: Build frontend
        working-directory: web
        run: yarn build

      - name: Analyze bundle size
        working-directory: web
        run: |
          set -euo pipefail
          {
            echo "### Bundle Size"
            echo ""
            echo "| Asset | Size | Gzip |"
            echo "|-------|------|------|"
            find dist -type f \( -name "*.js" -o -name "*.css" \) -exec sh -c '
              file="$1"
              size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file")
              gzip_size=$(gzip -c "$file" | wc -c)
              printf "| %s | %s | %s |\n" \
                "$(basename "$file")" \
                "$(numfmt --to=iec-i --suffix=B $size 2>/dev/null || echo "${size}B")" \
                "$(numfmt --to=iec-i --suffix=B $gzip_size 2>/dev/null || echo "${gzip_size}B")"
            ' _ {} \; | sort -k3 -h -r
            echo ""
            total_size=$(find dist -type f \( -name "*.js" -o -name "*.css" \) -exec stat -f%z {} + 2>/dev/null | awk '{sum+=$1} END {print sum}' || \
                         find dist -type f \( -name "*.js" -o -name "*.css" \) -exec stat -c%s {} + | awk '{sum+=$1} END {print sum}')
            echo "**Total:** $(numfmt --to=iec-i --suffix=B $total_size 2>/dev/null || echo "${total_size}B")"
          } >> "$GITHUB_STEP_SUMMARY"
